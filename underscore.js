// Generated by CoffeeScript 1.9.0
(function() {
  window._ = {};

  _.identity = function(val) {
    return val;
  };

  _.first = function(array, n) {
    if (n != null) {
      return array.slice(0, n);
    } else {
      return array[0];
    }
  };

  _.last = function(array, n) {
    if (n > array.length) {
      return array;
    }
    if (n != null) {
      return array.slice(array.length - n, array.length);
    } else {
      return array[array.length - 1];
    }
  };

  _.each = function(collection, iterator) {
    var index, item, key, _i, _len, _results, _results1;
    if (Array.isArray(collection)) {
      _results = [];
      for (index = _i = 0, _len = collection.length; _i < _len; index = ++_i) {
        item = collection[index];
        _results.push(iterator(item, index, collection));
      }
      return _results;
    } else {
      _results1 = [];
      for (key in collection) {
        item = collection[key];
        _results1.push(iterator(item, key, collection));
      }
      return _results1;
    }
  };

  _.indexOf = function(array, target) {
    var result;
    result = -1;
    _.each(array, function(item, index) {
      if (item === target && result === -1) {
        return result = index;
      }
    });
    return result;
  };

  _.filter = function(collection, test) {
    var results;
    results = [];
    _.each(collection, function(item) {
      if (test(item)) {
        return results.push(item);
      }
    });
    return results;
  };

  _.reject = function(collection, test) {
    return _.filter(collection, function(item) {
      return !test(item);
    });
  };

  _.uniq = function(array) {
    var results;
    results = [];
    _.each(array, function(item) {
      if (_.indexOf(results, item) === -1) {
        return results.push(item);
      }
    });
    return results;
  };

  _.map = function(collection, iterator) {
    var results;
    results = [];
    _.each(collection, function(item) {
      return results.push(iterator(item));
    });
    return results;
  };

  _.pluck = function(collection, key) {
    return _.map(collection, function(item) {
      return item[key];
    });
  };

  _.reduce = function(collection, iterator, accumulator) {
    if (accumulator == null) {
      accumulator = collection.shift();
    }
    _.each(collection, function(item) {
      return accumulator = iterator(accumulator, item);
    });
    return accumulator;
  };

  _.contains = function(collection, target) {
    if (_.indexOf(collection, target) === -1) {
      return false;
    } else {
      return true;
    }
  };

  _.every = function(collection, iterator) {
    iterator = iterator || _.identity;
    return !!_.reduce(collection, function(accumulator, value) {
      return accumulator && iterator(value);
    }, true);
  };

  _.some = function(collection, iterator) {
    iterator = iterator || _.identity;
    return !_.every(collection, function(value) {
      return !iterator(value);
    });
  };

  _.extend = function(obj) {
    var args;
    args = Array.prototype.slice.call(arguments);
    _.each(args, function(arg) {
      return _.each(arg, function(item, key) {
        return obj[key] = item;
      });
    });
    return obj;
  };

  _.defaults = function(obj) {
    var args;
    args = Array.prototype.slice.call(arguments);
    _.each(args, function(arg) {
      return _.each(arg, function(item, key) {
        if (obj[key] == null) {
          return obj[key] = item;
        }
      });
    });
    return obj;
  };

  _.once = function(func) {
    var alreadyCalled, result;
    alreadyCalled = false;
    result = void 0;
    return function() {
      if (!alreadyCalled) {
        result = func.apply(this, arguments);
        alreadyCalled = true;
      }
      return result;
    };
  };

  _.memoize = function(func) {
    var cache;
    cache = {};
    return function() {
      var args;
      args = Array.prototype.slice.call(arguments);
      if (cache[args] == null) {
        cache[args] = func.apply(null, args);
      }
      return cache[args];
    };
  };

  _.delay = function(func, wait) {
    var args;
    args = Array.prototype.slice.call(arguments, 2);
    return setTimeout(function() {
      return func.apply(this, args);
    }, wait);
  };

  _.shuffle = function(array) {
    var ran, shuffled, used;
    used = [];
    while (used.length < array.length) {
      ran = Math.floor(Math.random() * array.length);
      if (!_.contains(used, ran)) {
        used.push(ran);
      }
    }
    shuffled = [];
    _.each(used, function(item) {
      return shuffled.push(array[item]);
    });
    if (shuffled.join() === array.join()) {
      return _.shuffle(array);
    } else {
      return shuffled;
    }
  };

}).call(this);
